<!DOCTYPE html>
<html>
<head>
    <title>PiDog Cloud Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #ffffff;
            margin: 0;
            padding: 40px;
            text-align: center;
        }
        h1 {
            color: #c62828;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .status {
            margin: 20px 0;
            padding: 10px;
            background-color: #263238;
            border-radius: 5px;
        }
        .success {
            color: #4caf50;
        }
        .button {
            display: inline-block;
            background-color: #c62828;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .button:hover {
            background-color: #ff5f52;
        }
        .button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .webcam-section {
            margin-top: 30px;
            padding: 20px;
            background-color: #1a1a1a;
            border-radius: 8px;
        }
        .video-container {
            margin: 20px auto;
            position: relative;
            width: 100%;
            max-width: 640px;
            overflow: hidden;
            border: 2px solid #f00;
            background-color: #000;
        }
        .video-stream {
            width: 100%;
            display: block;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .result-container {
            background-color: #263238;
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            overflow-y: auto;
            max-height: 200px;
            text-align: left;
        }
        .fps-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            color: #4caf50;
            padding: 5px;
            border-radius: 3px;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin: 0 10px;
        }
        .tab.active {
            border-bottom: 2px solid #c62828;
            font-weight: bold;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .robot-control {
            margin-top: 20px;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 8px;
        }
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 10px;
            margin: 20px auto;
            max-width: 300px;
        }
        .control-grid button {
            width: 100%;
            height: 60px;
            font-size: 1.2rem;
            font-weight: bold;
        }
        .control-actions {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        .control-actions button {
            min-width: 120px;
        }
        .client-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #263238;
            border-radius: 5px;
            text-align: left;
        }
        .client-list {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .client-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: #1e1e1e;
            border-radius: 5px;
            cursor: pointer;
        }
        .client-item:hover {
            background-color: #333;
        }
        .client-item.selected {
            border: 2px solid #4caf50;
        }
        .led-control {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .led-btn {
            width: 60px;
            height: 40px;
            font-size: 0.8rem;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .sound-control {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .sound-btn {
            background-color: #673ab7;
        }
        .mode-switch {
            margin: 20px 0;
        }
        .info {
            margin: 20px 0;
            padding: 10px;
            background-color: #444;
            border-radius: 5px;
            border-left: 4px solid #f00;
        }
        .explosion-warning {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 0, 0, 0.5);
            z-index: 1000;
            animation: pulse 0.5s infinite alternate;
            text-align: center;
            padding-top: 40vh;
            font-size: 48px;
            font-weight: bold;
            text-shadow: 0 0 10px #fff;
        }
        @keyframes pulse {
            from { background-color: rgba(255, 0, 0, 0.5); }
            to { background-color: rgba(255, 0, 0, 0.8); }
        }
        .logs {
            margin: 20px 0;
            padding: 10px;
            background-color: #222;
            border-radius: 5px;
            color: #0f0;
            font-family: monospace;
            text-align: left;
            height: 100px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <div id="explosion-warning" class="explosion-warning">
        ⚠️ EXPLOSION ⚠️<br>
        <span style="font-size: 24px">CIBLE ÉLIMINÉE</span>
    </div>

    <div class="container">
        <h1>PiDog Cloud Control</h1>
        
        <div class="status">
            <p class="success">Le serveur est en ligne!</p>
            <p>Cette page est l'interface de contrôle de PiDog. Le serveur est prêt à recevoir des connexions et à traiter les images.</p>
        </div>
        
        <div class="tabs">
            <div class="tab" onclick="showTab('control')">Interface de contrôle</div>
            <div class="tab" onclick="showTab('connection')">Connexion</div>
            <div class="tab" onclick="showTab('webcam')">Test Webcam</div>
        </div>
        
        <div id="connection-tab" class="tab-content">
            <h2>Comment se connecter</h2>
            <p>Sur votre Raspberry Pi, exécutez:</p>
            <pre style="background:#000; color:#fff; padding:10px; border-radius:5px; text-align:left;">python pidog_client.py --server wss://killerrobot-production.up.railway.app/ws/pidog-client --client-id pidog-client-xyz</pre>
            <p>Remplacez "pidog-client-xyz" par un identifiant unique pour votre robot.</p>
            
            <div class="client-list" id="clientList">
                <h3>Robots connectés</h3>
                <div id="clientListItems">
                    <p>Aucun robot connecté pour le moment...</p>
                </div>
            </div>
        </div>
        
        <div id="control-tab" class="tab-content active">
            <h2>Contrôle du robot</h2>
            
            <div class="client-info" id="selectedClientInfo">
                <p>Aucun robot sélectionné. Veuillez vous connecter et sélectionner un robot dans l'onglet "Connexion".</p>
            </div>
            
            <div id="videoSection" class="webcam-section">
                <h3>Flux vidéo du robot</h3>
                <div class="video-container">
                    <img id="robotVideoStream" class="video-stream" src="/static/placeholder.jpg" alt="Vidéo du robot" onerror="this.src='/static/no-video.jpg'">
                    <div class="fps-indicator" id="fpsIndicator">0 FPS</div>
                </div>
                
                <div class="info">
                    <p>Distance: <span id="distance">Scanning...</span> cm</p>
                    <p>Mode: <span id="mode">Manuel</span></p>
                </div>
                
                <div class="mode-switch">
                    <button class="button" onclick="toggleMode()" id="modeBtn">Passer en mode autonome</button>
                </div>
                
                <div class="controls">
                    <button class="button" onclick="sendCommand('forward')" id="forwardBtn">Avancer</button>
                    <button class="button" onclick="sendCommand('backward')" id="backwardBtn">Reculer</button>
                    <button class="button" onclick="sendCommand('turn_left')" id="leftBtn">Tourner à gauche</button>
                    <button class="button" onclick="sendCommand('turn_right')" id="rightBtn">Tourner à droite</button>
                    <button class="button" onclick="sendCommand('stand')" id="standBtn">Debout</button>
                    <button class="button" onclick="sendCommand('sit')" id="sitBtn">Assis</button>
                    <button class="button" onclick="sendCommand('bark')" id="barkBtn">Aboyer</button>
                    <button class="button" onclick="sendCommand('aggressive_mode')" id="aggressiveBtn">MODE ATTAQUE</button>
                </div>
                
                <div class="logs" id="logBox">
                    <p>Logs du système:</p>
                </div>
            </div>
        </div>
        
        <div id="webcam-tab" class="tab-content">
            <h2>Test avec votre webcam</h2>
            <p>Cette section vous permet de tester la détection de personnes avec votre propre webcam.</p>
            
            <div id="localVideoSection" class="webcam-section">
                <div class="video-container">
                    <video id="localVideo" autoplay muted style="display: none;"></video>
                    <canvas id="localVideoCanvas" width="640" height="480"></canvas>
                </div>
                
                <div class="controls">
                    <button class="button" id="startWebcamBtn">Démarrer la webcam</button>
                    <button class="button" id="stopWebcamBtn" disabled>Arrêter la webcam</button>
                </div>
                
                <div class="result-container" id="detectionResults">
                    <p>Les résultats de détection s'afficheront ici...</p>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Variables globales
        let selectedClientId = null;
        let videoInterval = null;
        let fpsCounter = 0;
        let lastFpsUpdate = Date.now();
        let autoMode = false;
        let explosionTimeout = null;
        let updateDistanceInterval = null;
        
        // Fonction pour ajouter un message au log
        function log(message) {
            const logBox = document.getElementById('logBox');
            const now = new Date();
            const timestamp = now.toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.textContent = `[${timestamp}] ${message}`;
            logBox.appendChild(logEntry);
            logBox.scrollTop = logBox.scrollHeight;
        }
        
        // Afficher l'onglet sélectionné
        function showTab(tabName) {
            // Masquer tous les onglets
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Masquer tous les boutons d'onglet actifs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Afficher l'onglet sélectionné
            document.getElementById(`${tabName}-tab`).classList.add('active');
            
            // Marquer le bouton d'onglet comme actif
            document.querySelectorAll('.tab').forEach(tab => {
                if (tab.textContent.toLowerCase().includes(tabName.toLowerCase())) {
                    tab.classList.add('active');
                }
            });
        }
        
        // Rafraîchir la liste des clients
        function refreshClientList() {
            fetch('/clients')
                .then(response => response.json())
                .then(data => {
                    const clientListItems = document.getElementById('clientListItems');
                    
                    if (data.clients.length === 0) {
                        clientListItems.innerHTML = '<p>Aucun robot connecté pour le moment...</p>';
                        return;
                    }
                    
                    let html = '';
                    data.clients.forEach(clientId => {
                        const selected = clientId === selectedClientId ? 'selected' : '';
                        html += `<div class="client-item ${selected}" onclick="selectClient('${clientId}')">${clientId}</div>`;
                    });
                    
                    clientListItems.innerHTML = html;
                })
                .catch(error => {
                    console.error('Error fetching clients:', error);
                    log(`Erreur lors de la récupération des clients: ${error}`);
                });
        }
        
        // Sélectionner un client
        function selectClient(clientId) {
            selectedClientId = clientId;
            
            // Mettre à jour l'interface
            document.querySelectorAll('.client-item').forEach(item => {
                item.classList.remove('selected');
                if (item.textContent === clientId) {
                    item.classList.add('selected');
                }
            });
            
            // Mettre à jour les informations du client sélectionné
            document.getElementById('selectedClientInfo').innerHTML = `
                <h3>Robot sélectionné: ${clientId}</h3>
                <p>Utilisez les contrôles ci-dessous pour piloter le robot.</p>
            `;
            
            // Passer à l'onglet de contrôle
            showTab('control');
            
            // Démarrer la diffusion vidéo
            startVideoStream();
            
            // Commencer à mettre à jour la distance
            startDistanceUpdates();
            
            log(`Robot connecté: ${clientId}`);
        }
        
        // Démarrer la diffusion vidéo
        function startVideoStream() {
            if (!selectedClientId) return;
            
            // Arrêter l'intervalle existant s'il y en a un
            if (videoInterval) {
                clearInterval(videoInterval);
            }
            
            const videoElement = document.getElementById('robotVideoStream');
            
            // Fonction pour mettre à jour l'image
            function updateVideoFrame() {
                if (!selectedClientId) return;
                
                // Ajouter un timestamp pour éviter la mise en cache
                const timestamp = new Date().getTime();
                videoElement.src = `/client/${selectedClientId}/latest_frame?t=${timestamp}`;
                
                // Compter les FPS
                fpsCounter++;
                
                // Mettre à jour l'affichage FPS toutes les secondes
                const now = Date.now();
                if (now - lastFpsUpdate >= 1000) {
                    const fps = fpsCounter;
                    document.getElementById('fpsIndicator').textContent = `${fps} FPS`;
                    fpsCounter = 0;
                    lastFpsUpdate = now;
                }
            }
            
            // Mettre à jour l'image toutes les 100ms (environ 10 FPS)
            videoInterval = setInterval(updateVideoFrame, 100);
            
            // Mettre à jour immédiatement
            updateVideoFrame();
        }
        
        // Démarrer les mises à jour de distance
        function startDistanceUpdates() {
            if (!selectedClientId) return;
            
            // Arrêter l'intervalle existant s'il y en a un
            if (updateDistanceInterval) {
                clearInterval(updateDistanceInterval);
            }
            
            function updateDistance() {
                if (!selectedClientId) return;
                
                fetch(`/client/${selectedClientId}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.distance) {
                            document.getElementById('distance').textContent = data.distance;
                            
                            // Vérifier si la distance est assez proche pour une explosion
                            if (data.distance < 20) {
                                showExplosion();
                                log('🔥 EXPLOSION DÉCLENCHÉE - CIBLE ÉLIMINÉE 🔥');
                            }
                        } else {
                            document.getElementById('distance').textContent = 'N/A';
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching distance:', error);
                    });
            }
            
            // Mettre à jour la distance toutes les secondes
            updateDistanceInterval = setInterval(updateDistance, 1000);
            
            // Mettre à jour immédiatement
            updateDistance();
        }
        
        // Envoyer une commande au robot
        function sendCommand(command) {
            if (!selectedClientId) {
                log('Aucun robot sélectionné');
                return;
            }
            
            // Désactiver les contrôles si en mode autonome
            if (autoMode && ['forward', 'backward', 'turn_left', 'turn_right', 'stand', 'sit'].includes(command)) {
                log('Impossible d\'envoyer des commandes de mouvement en mode autonome');
                return;
            }
            
            log(`Envoi de la commande: ${command}`);
            
            fetch(`/client/${selectedClientId}/command`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    client_id: selectedClientId,
                    command_type: 'control',
                    data: {
                        action: command
                    }
                }),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Command sent:', data);
                log(`Réponse: ${data.message || 'Commande envoyée'}`);
            })
            .catch(error => {
                console.error('Error sending command:', error);
                log(`Erreur d'envoi de commande: ${error}`);
            });
        }
        
        // Basculer entre les modes autonome et manuel
        function toggleMode() {
            if (!selectedClientId) {
                log('Aucun robot sélectionné');
                return;
            }
            
            autoMode = !autoMode;
            
            log(`Changement de mode: ${autoMode ? 'Autonome' : 'Manuel'}`);
            
            // Mettre à jour l'interface
            document.getElementById('mode').textContent = autoMode ? 'Autonome' : 'Manuel';
            document.getElementById('modeBtn').textContent = autoMode ? 'Passer en mode manuel' : 'Passer en mode autonome';
            
            // Activer/désactiver les boutons de contrôle
            const controlButtons = ['forwardBtn', 'backwardBtn', 'leftBtn', 'rightBtn', 'standBtn', 'sitBtn'];
            controlButtons.forEach(id => {
                document.getElementById(id).disabled = autoMode;
            });
            
            // Envoyer la commande de changement de mode au robot
            fetch(`/client/${selectedClientId}/command`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    client_id: selectedClientId,
                    command_type: 'control',
                    data: {
                        action: 'set_mode',
                        mode: autoMode ? 'auto' : 'manual'
                    }
                }),
            })
            .then(response => response.json())
            .then(data => {
                console.log('Mode changed:', data);
                log(`Mode ${autoMode ? 'autonome' : 'manuel'} activé`);
            })
            .catch(error => {
                console.error('Error changing mode:', error);
                log(`Erreur de changement de mode: ${error}`);
            });
        }
        
        // Afficher l'avertissement d'explosion
        function showExplosion() {
            const explosionWarning = document.getElementById('explosion-warning');
            explosionWarning.style.display = 'block';
            
            // Effacer le timeout existant s'il y en a un
            if (explosionTimeout) {
                clearTimeout(explosionTimeout);
            }
            
            // Masquer après 3 secondes
            explosionTimeout = setTimeout(() => {
                explosionWarning.style.display = 'none';
            }, 3000);
        }
        
        // Gestion de la webcam locale pour les tests
        let localStream = null;
        let localVideoElement = document.getElementById('localVideo');
        let localCanvas = document.getElementById('localVideoCanvas');
        let localCanvasCtx = localCanvas.getContext('2d');
        let localVideoInterval = null;
        
        document.getElementById('startWebcamBtn').addEventListener('click', async () => {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true });
                localVideoElement.srcObject = localStream;
                
                document.getElementById('startWebcamBtn').disabled = true;
                document.getElementById('stopWebcamBtn').disabled = false;
                
                // Démarrer la capture et la détection
                startLocalDetection();
            } catch (error) {
                console.error('Error accessing webcam:', error);
                document.getElementById('detectionResults').innerHTML = `<p>Erreur d'accès à la webcam: ${error.message}</p>`;
            }
        });
        
        document.getElementById('stopWebcamBtn').addEventListener('click', () => {
            if (localVideoInterval) {
                clearInterval(localVideoInterval);
                localVideoInterval = null;
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
                localVideoElement.srcObject = null;
            }
            
            document.getElementById('startWebcamBtn').disabled = false;
            document.getElementById('stopWebcamBtn').disabled = true;
        });
        
        function startLocalDetection() {
            if (localVideoInterval) {
                clearInterval(localVideoInterval);
            }
            
            localVideoInterval = setInterval(() => {
                // Dessiner la vidéo sur le canvas
                localCanvasCtx.drawImage(localVideoElement, 0, 0, localCanvas.width, localCanvas.height);
                
                // Capturer l'image du canvas
                localCanvas.toBlob(blob => {
                    if (!blob) return;
                    
                    // Envoyer l'image pour détection
                    const formData = new FormData();
                    formData.append('image', blob, 'webcam.jpg');
                    
                    fetch('/detect-webcam', {
                        method: 'POST',
                        body: formData
                    })
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Afficher les résultats
                            document.getElementById('detectionResults').innerHTML = `
                                <p>Personnes détectées: ${data.detections.length}</p>
                                <p>Temps d'inférence: ${data.inference_time.toFixed(3)} secondes</p>
                            `;
                            
                            // Dessiner les boîtes de détection
                            data.detections.forEach(detection => {
                                const { x1, y1, x2, y2 } = detection.bbox;
                                
                                // Dessiner la boîte
                                localCanvasCtx.strokeStyle = '#ff0000';
                                localCanvasCtx.lineWidth = 2;
                                localCanvasCtx.strokeRect(x1, y1, x2 - x1, y2 - y1);
                                
                                // Ajouter l'étiquette
                                localCanvasCtx.fillStyle = 'rgba(255, 0, 0, 0.7)';
                                localCanvasCtx.fillRect(x1, y1 - 20, 120, 20);
                                localCanvasCtx.fillStyle = '#ffffff';
                                localCanvasCtx.font = '12px Arial';
                                localCanvasCtx.fillText(`Personne: ${detection.confidence.toFixed(2)}`, x1 + 5, y1 - 5);
                            });
                        } else {
                            document.getElementById('detectionResults').innerHTML = `<p>Erreur de détection: ${data.error || 'Inconnue'}</p>`;
                        }
                    })
                    .catch(error => {
                        console.error('Error in detection:', error);
                        document.getElementById('detectionResults').innerHTML = `<p>Erreur de détection: ${error.message}</p>`;
                    });
                }, 'image/jpeg');
            }, 500);  // Exécuter toutes les 500ms (2 FPS)
        }
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            // Actualiser la liste des clients toutes les 5 secondes
            setInterval(refreshClientList, 5000);
            
            // Première actualisation
            refreshClientList();
            
            log('Interface de contrôle initialisée');
        });
    </script>
</body>
</html> 