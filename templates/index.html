<!DOCTYPE html>
<html>
<head>
    <title>PiDog Cloud Control</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #121212;
            color: #ffffff;
            margin: 0;
            padding: 40px;
            text-align: center;
        }
        h1 {
            color: #c62828;
            font-size: 2rem;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
        }
        .status {
            margin: 20px 0;
            padding: 10px;
            background-color: #263238;
            border-radius: 5px;
        }
        .success {
            color: #4caf50;
        }
        .button {
            display: inline-block;
            background-color: #c62828;
            color: white;
            text-decoration: none;
            padding: 10px 20px;
            margin: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        .button:hover {
            background-color: #ff5f52;
        }
        .button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        .webcam-section {
            display: none;
            margin-top: 30px;
            padding: 20px;
            background-color: #1a1a1a;
            border-radius: 8px;
        }
        .video-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin: 20px 0;
        }
        .video-box {
            flex: 1;
            min-width: 320px;
            position: relative;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            border: 2px solid #c62828;
            background-color: #000;
        }
        canvas {
            width: 100%;
            display: block;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        .result-container {
            background-color: #263238;
            padding: 10px;
            border-radius: 4px;
            margin-top: 20px;
            overflow-y: auto;
            max-height: 200px;
            text-align: left;
        }
        .fps-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0,0,0,0.7);
            color: #4caf50;
            padding: 5px;
            border-radius: 3px;
            font-size: 14px;
        }
        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin: 0 10px;
        }
        .tab.active {
            border-bottom: 2px solid #c62828;
            font-weight: bold;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .robot-control {
            margin-top: 20px;
            padding: 20px;
            background-color: #1e1e1e;
            border-radius: 8px;
        }
        .control-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 10px;
            margin: 20px auto;
            max-width: 300px;
        }
        .control-grid button {
            width: 100%;
            height: 60px;
            font-size: 1.2rem;
            font-weight: bold;
        }
        .control-actions {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
        }
        .control-actions button {
            min-width: 120px;
        }
        .client-info {
            margin-top: 20px;
            padding: 15px;
            background-color: #263238;
            border-radius: 5px;
            text-align: left;
        }
        .client-list {
            margin-top: 20px;
            max-height: 300px;
            overflow-y: auto;
        }
        .client-item {
            padding: 10px;
            margin-bottom: 10px;
            background-color: #1e1e1e;
            border-radius: 5px;
            cursor: pointer;
        }
        .client-item:hover {
            background-color: #333;
        }
        .client-item.selected {
            border: 2px solid #4caf50;
        }
        .led-control {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .led-btn {
            width: 60px;
            height: 40px;
            font-size: 0.8rem;
            border: none;
            color: white;
            cursor: pointer;
            border-radius: 4px;
        }
        .sound-control {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        .sound-btn {
            background-color: #673ab7;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>PiDog Cloud Control</h1>
        
        <div class="status">
            <p class="success">Le serveur est en ligne!</p>
            <p>Cette page est l'interface de contrôle de PiDog. Le serveur est prêt à recevoir des connexions et à traiter les images.</p>
        </div>
        
        <div class="tabs">
            <div class="tab active" onclick="showTab('connection')">Connexion</div>
            <div class="tab" onclick="showTab('control')">Contrôle</div>
            <div class="tab" onclick="showTab('webcam')">Test Webcam</div>
        </div>
        
        <div id="connection-tab" class="tab-content active">
            <h2>Comment se connecter</h2>
            <p>Sur votre Raspberry Pi, exécutez:</p>
            <pre style="background:#000; color:#fff; padding:10px; border-radius:5px; text-align:left;">python pidog_client.py --server ws://killerrobot-production.up.railway.app:8080/ws</pre>
            <p>Remplacez ADRESSE_SERVEUR par l'URL de ce service.</p>
            
            <div class="client-list" id="clientList">
                <h3>Robots connectés</h3>
                <div id="clientListItems">
                    <p>Aucun robot connecté pour le moment...</p>
                </div>
            </div>
        </div>
        
        <div id="control-tab" class="tab-content">
            <h2>Contrôle du robot</h2>
            <p>Cette section vous permet de contrôler le robot à distance.</p>
            
            <div class="client-info" id="selectedClientInfo">
                <p>Aucun robot sélectionné. Veuillez vous connecter et sélectionner un robot dans l'onglet "Connexion".</p>
            </div>
            
            <div class="robot-control">
                <h3>Mouvements</h3>
                <div class="control-grid">
                    <button class="button" id="btnNone1"></button>
                    <button class="button" id="btnForward">Avant</button>
                    <button class="button" id="btnNone2"></button>
                    <button class="button" id="btnLeft">Gauche</button>
                    <button class="button" id="btnStop">Stop</button>
                    <button class="button" id="btnRight">Droite</button>
                    <button class="button" id="btnNone3"></button>
                    <button class="button" id="btnBackward">Arrière</button>
                    <button class="button" id="btnNone4"></button>
                </div>
                
                <div class="control-actions">
                    <button class="button" id="btnSit">S'asseoir</button>
                    <button class="button" id="btnStand">Se lever</button>
                    <button class="button" id="btnDance">Danser</button>
                </div>
                
                <h3>Effets lumineux</h3>
                <div class="led-control">
                    <button class="button led-btn" style="background-color: #f44336;" id="btnLedRed">Rouge</button>
                    <button class="button led-btn" style="background-color: #4caf50;" id="btnLedGreen">Vert</button>
                    <button class="button led-btn" style="background-color: #2196f3;" id="btnLedBlue">Bleu</button>
                    <button class="button led-btn" style="background-color: #ffeb3b; color: black;" id="btnLedYellow">Jaune</button>
                    <button class="button led-btn" style="background-color: #9c27b0;" id="btnLedPurple">Violet</button>
                    <button class="button led-btn" style="background-color: #ff9800;" id="btnLedOrange">Orange</button>
                    <button class="button led-btn" style="background-color: #333;" id="btnLedOff">Off</button>
                </div>
                
                <h3>Sons</h3>
                <div class="sound-control">
                    <button class="button sound-btn" id="btnSoundBark">Aboiement</button>
                    <button class="button sound-btn" id="btnSoundBeep">Bip</button>
                </div>
            </div>
        </div>
        
        <div id="webcam-tab" class="tab-content">
            <h2>Test de détection avec webcam locale</h2>
            <p>Cette section vous permet de tester le modèle de détection YOLOv8 sur le cloud en utilisant votre webcam locale.</p>
            
            <div class="video-container">
                <div class="video-box">
                    <h3>Webcam en direct</h3>
                    <div class="canvas-container">
                        <canvas id="webcamCanvas"></canvas>
                        <div id="detectionOverlay"></div>
                        <div id="fpsIndicator" class="fps-indicator">0 FPS</div>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <button id="startButton" class="button">Démarrer la webcam</button>
                <button id="stopButton" class="button" disabled>Arrêter</button>
            </div>
            
            <div class="result-container" id="results">
                <p>Les résultats de détection s'afficheront ici...</p>
            </div>
        </div>
    </div>
    
    <script>
        // Variables globales
        let selectedClientId = null;
        let clientStatusInterval = null;
        
        // Fonction pour afficher un onglet
        function showTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(tabName + '-tab').classList.add('active');
            document.querySelector(`.tab[onclick="showTab('${tabName}')"]`).classList.add('active');
        }
        
        // Fonction pour mettre à jour la liste des clients
        async function updateClientList() {
            try {
                const response = await fetch('/clients');
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                const clientListContainer = document.getElementById('clientListItems');
                
                if (data.clients && data.clients.length > 0) {
                    let html = '';
                    data.clients.forEach(clientId => {
                        const clientInfo = data.status[clientId] || {};
                        const isSelected = clientId === selectedClientId;
                        const hasCamera = clientInfo.has_camera || false;
                        const hasImu = clientInfo.has_imu || false;
                        
                        html += `
                            <div class="client-item ${isSelected ? 'selected' : ''}" onclick="selectClient('${clientId}')">
                                <strong>Robot ID:</strong> ${clientId}<br>
                                <strong>IP:</strong> ${clientInfo.ip_address || 'Inconnue'}<br>
                                <strong>Caméra:</strong> ${hasCamera ? '✓' : '✗'} &nbsp;
                                <strong>IMU:</strong> ${hasImu ? '✓' : '✗'}
                            </div>
                        `;
                    });
                    clientListContainer.innerHTML = html;
                } else {
                    clientListContainer.innerHTML = '<p>Aucun robot connecté pour le moment...</p>';
                }
            } catch (error) {
                console.error('Erreur lors de la récupération des clients:', error);
            }
        }
        
        // Fonction pour sélectionner un client
        function selectClient(clientId) {
            selectedClientId = clientId;
            updateClientList(); // Mettre à jour l'affichage avec la sélection
            updateSelectedClientInfo();
            
            // Activer le panneau de contrôle
            showTab('control');
        }
        
        // Fonction pour mettre à jour les informations du client sélectionné
        async function updateSelectedClientInfo() {
            const infoContainer = document.getElementById('selectedClientInfo');
            
            if (!selectedClientId) {
                infoContainer.innerHTML = '<p>Aucun robot sélectionné. Veuillez vous connecter et sélectionner un robot dans l\'onglet "Connexion".</p>';
                return;
            }
            
            try {
                const response = await fetch('/clients');
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }
                
                const data = await response.json();
                const clientInfo = data.status[selectedClientId] || {};
                
                infoContainer.innerHTML = `
                    <h3>Robot sélectionné: ${selectedClientId}</h3>
                    <p><strong>Adresse IP:</strong> ${clientInfo.ip_address || 'Inconnue'}</p>
                    <p>
                        <strong>Capacités:</strong>
                        Caméra: ${clientInfo.has_camera ? '✓' : '✗'} &nbsp;
                        IMU (mouvements): ${clientInfo.has_imu ? '✓' : '✗'} &nbsp;
                        LED RGB: ${clientInfo.has_rgb ? '✓' : '✗'} &nbsp;
                        Capteur de distance: ${clientInfo.has_distance_sensor ? '✓' : '✗'}
                    </p>
                `;
                
                // Activer/désactiver les boutons en fonction des capacités
                document.querySelectorAll('.control-grid button, .control-actions button').forEach(btn => {
                    btn.disabled = !clientInfo.has_imu;
                });
                
                document.querySelectorAll('.led-control button').forEach(btn => {
                    btn.disabled = !clientInfo.has_rgb;
                });
                
            } catch (error) {
                console.error('Erreur lors de la récupération des informations du client:', error);
                infoContainer.innerHTML = `<p>Erreur lors de la récupération des informations: ${error.message}</p>`;
            }
        }
        
        // Fonction pour envoyer une commande au robot
        async function sendCommand(commandType, data = {}) {
            if (!selectedClientId) {
                alert('Veuillez sélectionner un robot avant d\'envoyer des commandes.');
                return;
            }
            
            try {
                const response = await fetch(`/client/${selectedClientId}/command`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        client_id: selectedClientId,
                        command_type: commandType,
                        data: data
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }
                
                const result = await response.json();
                console.log('Commande envoyée:', result);
                
                // Afficher un retour visuel temporaire
                const btnId = event.target.id;
                const btn = document.getElementById(btnId);
                const originalColor = btn.style.backgroundColor;
                btn.style.backgroundColor = '#4caf50';
                setTimeout(() => {
                    btn.style.backgroundColor = originalColor;
                }, 300);
                
            } catch (error) {
                console.error('Erreur lors de l\'envoi de la commande:', error);
                alert(`Erreur: ${error.message}`);
            }
        }
        
        // Fonction d'initialisation
        function initControlUI() {
            // Configuration des boutons de mouvement
            document.getElementById('btnForward').addEventListener('click', () => sendCommand('robot_action', { action: 'forward' }));
            document.getElementById('btnBackward').addEventListener('click', () => sendCommand('robot_action', { action: 'backward' }));
            document.getElementById('btnLeft').addEventListener('click', () => sendCommand('robot_action', { action: 'turn_left' }));
            document.getElementById('btnRight').addEventListener('click', () => sendCommand('robot_action', { action: 'turn_right' }));
            document.getElementById('btnStop').addEventListener('click', () => sendCommand('robot_action', { action: 'sit' }));
            
            // Configuration des boutons d'action
            document.getElementById('btnSit').addEventListener('click', () => sendCommand('robot_action', { action: 'sit' }));
            document.getElementById('btnStand').addEventListener('click', () => sendCommand('robot_action', { action: 'stand' }));
            document.getElementById('btnDance').addEventListener('click', () => sendCommand('robot_action', { action: 'dance' }));
            
            // Configuration des boutons LED
            document.getElementById('btnLedRed').addEventListener('click', () => sendCommand('rgb_control', { mode: 'breath', color: 'red' }));
            document.getElementById('btnLedGreen').addEventListener('click', () => sendCommand('rgb_control', { mode: 'breath', color: 'green' }));
            document.getElementById('btnLedBlue').addEventListener('click', () => sendCommand('rgb_control', { mode: 'breath', color: 'blue' }));
            document.getElementById('btnLedYellow').addEventListener('click', () => sendCommand('rgb_control', { mode: 'breath', color: 'yellow' }));
            document.getElementById('btnLedPurple').addEventListener('click', () => sendCommand('rgb_control', { mode: 'breath', color: 'purple' }));
            document.getElementById('btnLedOrange').addEventListener('click', () => sendCommand('rgb_control', { mode: 'breath', color: 'orange' }));
            document.getElementById('btnLedOff').addEventListener('click', () => sendCommand('rgb_control', { mode: 'off', color: 'black' }));
            
            // Configuration des boutons de son
            document.getElementById('btnSoundBark').addEventListener('click', () => sendCommand('speak', { sound: 'bark' }));
            document.getElementById('btnSoundBeep').addEventListener('click', () => sendCommand('speak', { sound: 'beep' }));
            
            // Désactiver les boutons vides dans la grille de contrôle
            document.getElementById('btnNone1').style.visibility = 'hidden';
            document.getElementById('btnNone2').style.visibility = 'hidden';
            document.getElementById('btnNone3').style.visibility = 'hidden';
            document.getElementById('btnNone4').style.visibility = 'hidden';
            
            // Démarrer la mise à jour régulière des clients
            updateClientList();
            setInterval(updateClientList, 5000);
        }
        
        // ===== Fonctionnalité webcam =====
        let webcamStream = null;
        let canvas = document.getElementById('webcamCanvas');
        let ctx = canvas.getContext('2d');
        let detectionOverlay = document.getElementById('detectionOverlay');
        let startButton = document.getElementById('startButton');
        let stopButton = document.getElementById('stopButton');
        let resultsDiv = document.getElementById('results');
        let fpsIndicator = document.getElementById('fpsIndicator');
        let detecting = false;
        let lastFrameTime = 0;
        let frameCount = 0;
        let lastFpsUpdateTime = 0;
        
        // Configuration
        const captureInterval = 100; // ms entre chaque capture
        const detectionInterval = 500; // ms entre chaque détection
        let lastDetectionTime = 0;
        
        // Fonction pour démarrer la webcam
        async function startWebcam() {
            try {
                webcamStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    } 
                });
                
                // Configurer le canvas
                const videoTrack = webcamStream.getVideoTracks()[0];
                const settings = videoTrack.getSettings();
                canvas.width = settings.width;
                canvas.height = settings.height;
                
                // Créer un élément vidéo invisible pour recevoir le flux
                const video = document.createElement('video');
                video.srcObject = webcamStream;
                video.play();
                
                // Mettre à jour les boutons
                startButton.disabled = true;
                stopButton.disabled = false;
                
                // Démarrer la capture et la détection
                detecting = true;
                captureAndDetect(video);
                
                addLogMessage('Webcam démarrée avec succès');
            } catch (error) {
                addLogMessage(`Erreur d'accès à la webcam: ${error.message}`, 'error');
                console.error('Erreur d\'accès à la webcam:', error);
            }
        }
        
        // Fonction pour arrêter la webcam
        function stopWebcam() {
            if (webcamStream) {
                webcamStream.getTracks().forEach(track => track.stop());
                webcamStream = null;
                detecting = false;
                
                // Effacer le canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                detectionOverlay.innerHTML = '';
                
                // Mettre à jour les boutons
                startButton.disabled = false;
                stopButton.disabled = true;
                
                addLogMessage('Webcam arrêtée');
            }
        }
        
        // Fonction pour capturer et détecter
        function captureAndDetect(video) {
            if (!detecting) return;
            
            const now = performance.now();
            
            // Calculer le FPS
            frameCount++;
            if (now - lastFpsUpdateTime > 1000) { // Mettre à jour le FPS chaque seconde
                const fps = Math.round(frameCount * 1000 / (now - lastFpsUpdateTime));
                fpsIndicator.textContent = `${fps} FPS`;
                frameCount = 0;
                lastFpsUpdateTime = now;
            }
            
            // Dessiner la frame de la webcam sur le canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // Exécuter la détection à l'intervalle spécifié
            if (now - lastDetectionTime > detectionInterval) {
                lastDetectionTime = now;
                
                // Convertir le canvas en blob pour l'envoyer au serveur
                canvas.toBlob(blob => {
                    if (blob) {
                        sendImageForDetection(blob);
                    }
                }, 'image/jpeg', 0.8);
            }
            
            // Planifier la prochaine capture
            setTimeout(() => captureAndDetect(video), captureInterval);
        }
        
        // Fonction pour envoyer l'image au serveur pour détection
        async function sendImageForDetection(blob) {
            try {
                const formData = new FormData();
                formData.append('image', blob);
                
                const response = await fetch('/detect-webcam', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`Erreur HTTP: ${response.status}`);
                }
                
                const detectionResult = await response.json();
                displayDetectionResults(detectionResult);
                
            } catch (error) {
                console.error('Erreur lors de la détection:', error);
                addLogMessage(`Erreur de détection: ${error.message}`, 'error');
            }
        }
        
        // Fonction pour afficher les résultats de détection
        function displayDetectionResults(results) {
            if (!results.success) {
                addLogMessage('Échec de la détection: ' + (results.error || 'Raison inconnue'), 'error');
                return;
            }
            
            // Effacer les détections précédentes
            detectionOverlay.innerHTML = '';
            
            // Log du temps d'inférence
            const inferenceTime = results.inference_time * 1000;
            addLogMessage(`Détection effectuée en ${inferenceTime.toFixed(1)}ms - ${results.detections.length} personnes détectées`);
            
            // Créer le contenu SVG pour l'overlay
            const svgNS = "http://www.w3.org/2000/svg";
            const svg = document.createElementNS(svgNS, "svg");
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.style.position = "absolute";
            svg.style.top = "0";
            svg.style.left = "0";
            svg.style.pointerEvents = "none";
            
            // Dessiner chaque détection
            results.detections.forEach(detection => {
                const { x1, y1, x2, y2 } = detection.bbox;
                const confidence = detection.confidence;
                
                // Calculer les dimensions relatives
                const imgWidth = results.image_size.width;
                const imgHeight = results.image_size.height;
                
                const relX = (x1 / imgWidth) * 100;
                const relY = (y1 / imgHeight) * 100;
                const relWidth = ((x2 - x1) / imgWidth) * 100;
                const relHeight = ((y2 - y1) / imgHeight) * 100;
                
                // Créer le rectangle
                const rect = document.createElementNS(svgNS, "rect");
                rect.setAttribute("x", `${relX}%`);
                rect.setAttribute("y", `${relY}%`);
                rect.setAttribute("width", `${relWidth}%`);
                rect.setAttribute("height", `${relHeight}%`);
                rect.setAttribute("fill", "none");
                rect.setAttribute("stroke", `rgba(255, 0, 0, ${confidence})`);
                rect.setAttribute("stroke-width", "2");
                
                // Créer l'étiquette
                const text = document.createElementNS(svgNS, "text");
                text.setAttribute("x", `${relX}%`);
                text.setAttribute("y", `${relY - 0.5}%`);
                text.setAttribute("fill", "#ff5f52");
                text.setAttribute("font-size", "12px");
                text.textContent = `Personne: ${(confidence * 100).toFixed(0)}%`;
                
                // Ajouter au SVG
                svg.appendChild(rect);
                svg.appendChild(text);
            });
            
            // Ajouter le SVG à l'overlay
            detectionOverlay.appendChild(svg);
        }
        
        // Fonction pour ajouter un message au log
        function addLogMessage(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.innerHTML = `<span style="color: #ff5f52;">[${timestamp}]</span> ${message}`;
            
            if (type === 'error') {
                logEntry.style.color = '#ff5252';
            }
            
            resultsDiv.appendChild(logEntry);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
            
            // Limiter le nombre d'entrées de log
            while (resultsDiv.children.length > 50) {
                resultsDiv.removeChild(resultsDiv.firstChild);
            }
        }
        
        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            // Initialiser l'interface de contrôle
            initControlUI();
            
            // Configurer les gestionnaires d'événements pour la webcam
            startButton.addEventListener('click', startWebcam);
            stopButton.addEventListener('click', stopWebcam);
            
            // Message initial pour la webcam
            addLogMessage('Prêt à démarrer la détection. Cliquez sur "Démarrer la webcam".');
        });
    </script>
</body>
</html> 